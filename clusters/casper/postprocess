#!/bin/bash
#
#   This script does final setup for the production
#   environment on the host system
#

# Perform common script setup including environment checks
export my_dir="$( cd "$(dirname "$0")" ; pwd )"
. $my_dir/tools/init.sh

# CONFIGURABLES
core_gcc=gcc@7.5.0
compilers="gcc nvhpc oneapi intel"
mpis="openmpi"
hide_list=""

if [[ $SPACK_ENV == $NCAR_SPACK_ENV_PUBLIC ]]; then
    mod_root=$NCAR_SPACK_ROOT_MODULES
    base_root=$NCAR_SPACK_ROOT_BASE
else
    mod_root=$SPACK_ENV/modules
    base_root=$SPACK_ENV
fi

mod_deployment=${mod_root}/$NCAR_SPACK_HOST_VERSION

while [[ $# -gt 0 ]]; do
    case $1 in
        -c|--clean)
            spack_flags=--delete-tree
            ;;
    esac

    shift
done

# First, let's make sure module tree exists
if [[ ! -d $mod_deployment ]] || [[ -n $spack_flags ]]; then
    spack module lmod refresh -y $spack_flags
fi

# ===== INTEL ONEAPI MODULE TRIO =====

tsecho "Populating Intel compiler module set"
cd $mod_deployment
tm_file=$SPACK_ENV/.tempmod

if [[ -d Core/intel-oneapi ]]; then
    mkdir -p Core/intel

    for icver in $(find Core/intel-oneapi/ -type f); do
        sed '/INTEL_COMPILER_TYPE/ s/ONEAPI/RECOMMENDED/' $icver > ${icver/-oneapi}
        sed -i 's|\([/"]\)ifx|\1intel64/ifort|' ${icver/-oneapi}
    done
fi

if [[ -d Core/intel-classic ]]; then
    for icver in $(find Core/intel-classic/ -type f); do
        ccver=$(sed -n '/INTEL_VERSION/ s|.*"\(.*\)".*|\1|p' $icver)
        onever=$(sed 's|.*/\(.*\)\.lua|\1|' <<< $icver)

        sed -i "/MODULEPATH/ s|intel|oneapi|" $icver
        sed -i "/MODULEPATH/ s|${ccver}|${onever}|" $icver
    done
fi

# ===== CREATE META-MODULES =====

function hide_module {
    hl_file=$SPACK_ENV/util/hidden-modules

    if [[ -f $hl_file ]]; then
        if grep -q $1 $hl_file; then
            return
        fi
    fi

    echo "hide-modulefile $1" >> $hl_file
}

sys_gcc=gcc@$(gcc -dumpfullversion)

if [[ $core_gcc != $sys_gcc ]]; then
    tsecho "Locate the core compiler for ncarenv"
    cc_root=$(spack location -i $core_gcc)
fi

# Make sure the meta-modules exist

# *This* ncarenv deployment
for mod_type in ncarenv ncarenv-basic; do
    mkdir -p $mod_root/environment/$mod_type
    mm_src=$NCAR_SPACK_ENV_BUILD/templates/modules/$mod_type.lua
    mm_file=$mod_root/environment/$mod_type/${NCAR_SPACK_HOST_VERSION}.lua

    sed "s|%MODPATH%|${mod_deployment}/Core|g" $mm_src > $tm_file
    sed -i "s|%BASEROOT%|${base_root}|g" $tm_file
    sed -i "s|%VERSION%|${NCAR_SPACK_HOST_VERSION}|g" $tm_file
    sed -i "s|%DATE%|$(date)|g" $tm_file
    sed -i "s|%UTILPATH%|${SPACK_ENV}/util|g" $tm_file
    sed -i "s|%DEFMODS%|$NCAR_SPACK_DEFMODS_NCAR|g" $tm_file
    sed -i "s|%HOST%|$NCAR_SPACK_HOST|g" $tm_file
    sed -i "s|%TMPROOT%|$NCAR_SPACK_TMPROOT|g" $tm_file
    sed -i "s|%CCROOT%|${cc_root}|g" $tm_file
    mv $tm_file $mm_file

    if [[ $mod_type != ncarenv ]]; then
        hide_module $mm_file
    fi
done

# Create developer addon modules and hide them
mkdir -p $mod_root/environment/cesmdev
mm_file=$mod_root/environment/cesmdev/1.0.lua
sed "s|%DATE%|$(date)|g" $NCAR_SPACK_ENV_BUILD/templates/modules/cesmdev.lua > $tm_file
mv $tm_file $mm_file
hide_module $mm_file

# ===== HIDE REQUESTED MODULES =====

for hl in $hide_list; do
    hide_mods="$(ls -1 --color=never $mod_deployment/$hl 2> /dev/null || true)"

    for hm in $hide_mods; do
        hide_module $hm
    done
done

# ===== FINALIZE BASE SHELL ENVIRONMENT =====

tsecho "Adding external utilities to the shell environment"

# Add utilities to the base environment when using ncarenv
util_root=/glade/u/apps/opt; cd $util_root

declare -A ncar_utils
ncar_utils[qstat]=qstat-cache
ncar_utils[qinteractive]=pbstools
ncar_utils[execcasper]=pbstools
ncar_utils[qcmd]=pbstools
ncar_utils[qhist]=qhist
ncar_utils[gladequota]=gladequota
ncar_utils[set_gpu_rank]=mpitools
ncar_utils[create_conda_kernel]=ncar-conda
ncar_utils[compare_env_yaml]=ncar-conda
ncar_utils[spack-downstream]=csg-spack-downstreams

skip_clone="gladequota mpitools"

if [[ $SPACK_ENV == $NCAR_SPACK_ENV_PUBLIC ]]; then
    mkdir -p $NCAR_SPACK_ROOT_BASE/utils/bin

    for util in ${!ncar_utils[@]}; do
        if [[ ! -d ${ncar_utils[$util]} ]]; then
            if [[ -O $util_root ]]; then
                if [[ " $skip_clone " != *" ${ncar_utils[$util]} "* ]]; then
                    tsecho "    cloning $GCOL${ncar_utils[$util]}$DCOL repo"
                    git clone git@github.com:NCAR/${ncar_utils[$util]}.git
                else
                    tsecho "Error: No github repo for $util. Perform manual install and retry!"
                    exit 1
                fi
            else
                echo "Note: Skipping missing utility ${util}. $(whoami) does not own $util_root ..."
                continue
            fi
        fi

        if [[ ! -e $NCAR_SPACK_ROOT_BASE/utils/bin/$util ]]; then
            if [[ -e $util_root/${ncar_utils[$util]}/bin/$util ]]; then
                tsecho "    adding $GCOL$util$DCOL"
                ln -s $util_root/${ncar_utils[$util]}/bin/$util $NCAR_SPACK_ROOT_BASE/utils/bin/
            else
                tsecho "Error: Expected binary not found ($util_root/${ncar_utils[$util]}/bin/$util)!"
                exit 1
            fi
        fi
    done
fi

tsecho "Finalize the Spack view"
view_root=$base_root/view

# Make sure RPC is available for WRF
if [[ ! -e $view_root/include/rpc ]] && [[ -d $view_root/include/tirpc/rpc ]]; then
    ln -s $view_root/include/tirpc/* $view_root/include/
fi

# ===== SET UP PERL LIBRARY =====

perl_mod_list="Pod::Parser HTML::Entities"
perl_lib_root=$NCAR_SPACK_ROOT_BASE/perl

if [[ $NCAR_SPACK_ENV_TYPE == public ]]; then
    tsecho "Checking for Spack-installed Perl"
    perl_hash=$(spack find -x --format '{hash}' perl)

    if [[ $? == 0 ]]; then
        tsecho "Populating Perl library"
        echo
        spack load /$perl_hash

        for pmod in $perl_mod_list; do
            cpanm install -L $perl_lib_root $pmod
        done

        spack unload /$perl_hash
        echo
    fi
fi

# ===== CREATE LMOD AVAIL HOOK =====

function create_sp {
cat > $tm_file << EOF
require("strict")
require("sandbox")
local hook = require("Hook")

local mapT =
{
   grouped = {
      ['/environment$'] = "Module Stack Environments",
      ['/Core$'] = "Compilers and Core Software",
EOF

comp_cat_list="aocc arm clang gcc intel nag oneapi nvhpc"
mpi_cat_list="hpcx-mpi intel-mpi intel-oneapi-mpi mpi-serial mpich mvapich2 mvapich2-gdr openmpi"

for comp_cat in $comp_cat_list; do
    for mpi_cat in $mpi_cat_list; do
        echo "      ['modules/[^/]+/${mpi_cat//-/%-}/[^/]+/$comp_cat/[^/]*$'] = 'MPI-dependent Software - [$comp_cat + $mpi_cat]'," >> $tm_file
    done

    echo "      ['modules/[^/]+/$comp_cat/[^/]*$'] = 'Compiler-dependent Software - [$comp_cat]'," >> $tm_file
done

cat >> $tm_file << EOF
   },
}

function avail_hook(t)
   local availStyle = masterTbl().availStyle
   local styleT     = mapT[availStyle]
   if (not availStyle or availStyle == "system" or styleT == nil) then
      return
   end

   for k,v in pairs(t) do
      for pat,label in pairs(styleT) do
         if (k:find(pat)) then
            t[k] = label
            break
         end
      end
   end
end

hook.register("avail",avail_hook)

function universal_mgrload(required, active)
   if (mode() == "load" or mode() == "unload") then
      MCP:mgrload(required, active)
   end
end

sandbox_registration {
    universal_mgrload = universal_mgrload
}
EOF
}

# Path to Lmod site hook file
sp_file=$SPACK_ENV/util/SitePackage.lua
create_sp
mv $tm_file $sp_file

# ===== CREATE LMOD PROPERTY TABLE =====

# Path to Lmod properties file
rc_file=$SPACK_ENV/util/lmodrc.lua

cat > $tm_file << EOF
local i18n = require("i18n")
propT = {
   source = {
      validT = { user = 1 },
      displayT = {
         user = { short = "(U)", full_color = false, color = "blue", doc = "User-generated downstream module", }
      },
   },
   state = {
      validT = { experimental = 1, testing = 1, obsolete = 1 },
      displayT = {
         experimental  = { short = "(E)", full_color = false,  color = "blue",  doc = i18n("ExplM"), },
         testing       = { short = "(T)", full_color = false,  color = "green", doc = i18n("TstM"), },
         obsolete      = { short = "(O)", full_color = false,  color = "red",   doc = i18n("ObsM"), },
      },
   },
   lmod = {
      validT = { sticky = 1 },
      displayT = {
         sticky = { short = "(S)",  color = "red",    doc = i18n("StickyM"), }
      },
   },
   status = {
      validT = { active = 1, },
      displayT = {
         active = { short = "(L)",  color = "yellow", doc = i18n("LoadedM")},
     },
   },
}
EOF

mv $tm_file $rc_file
