#!/bin/bash

function usage {
cat << EOF
Usage: $0 [-H HOSTFILE] [-j JOBS] [-p JOBS] [MANIFEST]

Options
    -H, --hostfile          a line-by-line file containing hosts to use
    -j, --jobs-per-host     number of build jobs to run on each host
    -p, --jobs-per-proc     number of build jobs to run per Spack process/instance
                            (must be less or equal to jobs per host)

EOF
exit
}

if [[ " $@ " == *" -h "* ]]; then
    usage
fi

# Perform common script setup including environment checks
export my_dir="$( cd "$(dirname "$0")" ; pwd )"
. $my_dir/tools/init.sh
my_host=$(hostname)

# Defaults
pkg_manifest=$SPACK_ENV/packages.cfg
jobs_per_host=$(spack config get config | sed -n 's/^[ ]*build_jobs: \(.*\)/\1/p')
jobs_per_proc=8
remote_env="NCAR_SPACK_ENV=$SPACK_ENV NCAR_SPACK_STARTUP=$NCAR_SPACK_STARTUP NCAR_SPACK_PYDIR=$NCAR_SPACK_PYDIR"

# See if it's a PBS job and use values
if [[ -n $PBS_NODEFILE ]]; then
    jobs_per_host=$NCPUS
    build_hosts=$(uniq $PBS_NODEFILE | xargs)
    batch_job=true
else
    build_hosts=$(uniq $SPACK_ENV/buildhosts.cfg | xargs)
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        -j|--jobs-per-host)
            jobs_per_host=$2
            shift
            ;;
        -p|--jobs-per-proc)
            jobs_per_proc=$2
            shift
            ;;
        -H|--hostfile)
            build_hosts=$(uniq $2 | xargs)
            shift
            ;;
        *)
            pkg_manifest=$1
            ;;
    esac

    shift
done

if [[ $jobs_per_proc -gt $jobs_per_host ]]; then
    jobs_per_proc=$jobs_per_host
    2>&1 echo "Error: jobs per Spack process ($jobs_per_proc) must be <= jobs per host ($jobs_per_host)"
    exit
fi

num_hosts=$(wc -w <<< $build_hosts)
start_time=${NCAR_SPACK_DEPLOY_TIME:-$(date +%y%m%dT%H%M)}

if [[ -n $build_jobs ]]; then
    build_cmd="spack install -j $build_jobs"
else
    build_cmd="spack install"
fi

cat << EOF

Start time          = $start_time
Spack environment   = $SPACK_ENV
Package manifest    = $pkg_manifest
Jobs per host       = $jobs_per_host
Jobs per process    = $jobs_per_proc
Hosts               = $build_hosts

Processing install manifest ...

EOF

function prepare_spec {
    declare -g spec="$pkg" comp=${comp:-$install_compiler} mpi=${mpi:-$install_mpi}
    [[ -n $comp ]] && spec="$(sed "s|%CMP%|%$comp|;t;s|$| %$comp|" <<< "$spec")"
    [[ -n $mpi ]]  && spec="$(sed "s|%MPI%|^$mpi|;t;s|$| ^$mpi|" <<< "$spec")"
    
    while [[ $spec == *:* ]]; do
        spec_opt="$(sed 's|.*<\([^>]*\)>.*|\1|' <<< "$spec")"
        IFS=: read opt_type opt_body <<< "$spec_opt"

        if [[ $comp == ${opt_type}* ]] || [[ $mpi == ${opt_type}* ]]; then
            spec="${spec/<$spec_opt>/$opt_body}"
        else
            spec="${spec/<$spec_opt>}"
        fi
    done
}

function add_spec {
    if [[ $install_build == false ]]; then
        tsecho "Skipping spec $PCOL$spec$BCOL$type_msg$DCOL (reason: build=false specified)"
    else
        skip_spec=false
        set +e

        if [[ -f $my_dir/.cache ]]; then
            spec_hash=$(grep "^${spec}:" $my_dir/.cache | cut -d: -f2)
        fi

        if [[ -n $spec_hash ]] && grep -q $spec_hash $SPACK_ENV/spack.lock; then
            skip_spec=true
        else
            spack_find_out=$(spack find -L $spec)

            if [[ $? == 0 ]]; then
                echo "${spec}:$(tail -n1 <<< $spack_find_out | cut -d' ' -f1)" >> $my_dir/.cache
                skip_spec=true
            else
                sed -i "/.*${spec_hash}/d" $my_dir/.cache
            fi
        fi

        set -e

        if [[ $skip_spec == true ]]; then
            tsecho "Skipping spec $PCOL$spec$BCOL$type_msg$DCOL (reason: already installed)"
        else
            # Ensure log directories are present
            if [[ -z $log_dir ]]; then
                log_dir=$SPACK_ENV/logs/installs.$start_time
                mkdir -p $log_dir
            fi

            tsecho "Adding spec   $GCOL$spec$BCOL$type_msg$DCOL to spack.yaml"
            spack spec -I -N $spec &>> $log_dir/specs
            spack add $spec &>> $log_dir/specs
            new_installs=true

            if [[ $spec == lmod* ]]; then
                new_lmod=true
            fi
        fi
    fi

    if [[ $install_type == mpi ]]; then
        if [[ -n $comp ]]; then
            type_msg=" (MPI)"
            mpis[$comp]="${mpis[$comp]} ${pkg//[[:blank:]]/}"
        else
            2>&1 echo "Error: cannot install an MPI without setting a compiler!"
            exit 1
        fi
    elif [[ $install_type == compiler ]]; then
        compilers="$compilers ${pkg//[[:blank:]]/}"
        type_msg=" (compiler)"
    fi
    
    unset type_msg
}

function start_installs {
    if [[ $new_installs == true ]]; then
        tsecho "Concretizing new specs"
        
        # Spack might use too many CPUs on logins and get us killed
        if [[ $batch_job == true ]]; then
            spack concretize &> /dev/null
        else
            taskset -c 0-7 spack concretize &> /dev/null
        fi

        tsecho "Installing $1 using $num_hosts hosts"
        install_jobs=$(sed "s/max/$jobs_per_host/" <<< ${install_jobs:-$jobs_per_proc})
        SECONDS=0

        for build_host in $build_hosts; do
            host_slots=$jobs_per_host hnum=1

            while [[ $host_slots -ge $jobs_per_proc ]]; do
                tsecho "Starting Spack with $install_jobs build jobs on $build_host"
                
                if [[ $build_host == localhost ]] || [[ $build_host == $my_host* ]]; then
                    $build_cmd &>> $log_dir/${build_host}.p$hnum &
                else
                    ssh -n $build_host $remote_env $my_dir/tools/remote_bash $build_cmd &>> $log_dir/${build_host}.p$hnum &
                fi

                pids="$pids $!"
                host_slots=$((host_slots - install_jobs)); ((hnum++))
                sleep 1
            done
        done

        echo
        tail -f $log_dir/*.p* | grep -e "Executing phase" -e "Successfully installed" &
        tpid=$!; wait $pids; kill $tpid
        echo
        tsecho "Installs finished after $SECONDS seconds"
        unset new_installs
    fi
}

function check_exclusions {
    for espec in ${install_exclude/,/ }; do
        if [[ $1 == ${espec}* ]]; then
            return 1
        fi
    done
}

function define_items {
    list_var=my_$1; unset $list_var
    restrict_var=install_$1

    if [[ -n ${!restrict_var} ]]; then
        for item in $2; do
            if [[ $item == ${!restrict_var}* ]]; then
                if [[ -n $list_var ]]; then
                    declare -g $list_var="${!list_var} $item"
                else
                    declare -g $list_var="$item"
                fi
            fi
        done
    else
        declare -g $list_var="${2# }"
    fi
}

# Pretty colors
GCOL="\033[1;32m" BCOL="\033[1;34m" PCOL="\033[1;35m" DCOL="\033[0m"

# MPI libraries for each compiler
declare -A mpis

while read pkg; do
    if [[ $pkg == \#* ]]; then
        continue
    elif [[ $pkg != *'<'* ]] && [[ $pkg == *:* ]]; then
        # If compilers were added, we need to add GCCs to compiler list
        if [[ $install_type == compiler ]]; then
            current_comps=$(spack config get compilers | grep spec | cut -d: -f2)
            start_installs compilers

            for comp in $compilers; do
                if [[ $current_comps != *${comp}* ]]; then
                    tsecho "Registering $comp as a compiler in spack.yaml"

                    if [[ $install_external == module ]]; then
                        module_name=$(cut -d' ' -f1 <<< "${comp/@//}")
                        (module purge; module load $module_name; spack compiler find > /dev/null)
                    else
                        spack compiler add $(spack location -i $comp) > /dev/null
                    fi
                fi
            done
        # If previous category had custom number of jobs or post-sync, start installs
        elif [[ -n $install_jobs ]] || [[ $install_sync == after ]]; then
            start_installs packages
        fi

        for ivar in ${!install_*}; do
            unset $ivar
        done
        
        install_build=true

        for mflag in $pkg; do
            case $mflag in
                *:)
                    install_mode=${mflag%:}
                    ;;
                *=*)
                    declare install_${mflag%=*}=${mflag#*=}
                    ;;
            esac
        done
    else
        unset comp mpi
        case $install_mode in
            mdep)
                define_items compilers "${install_compiler:-$compilers}"
                for comp in $my_compilers; do
                    check_exclusions $comp || continue
                    define_items mpis "${mpis[$comp]}"
                    for mpi in $my_mpis; do
                        check_exclusions $mpi || continue
                        prepare_spec
                        add_spec
                    done
                done
                ;;
            cdep)
                define_items compilers "$compilers"
                for comp in $my_compilers; do
                    check_exclusions $comp || continue
                    prepare_spec
                    add_spec
                done
                ;;
            singleton)
                prepare_spec
                add_spec
                ;;
            *)
                echo -e "\n====="
                echo "Error: unrecognized install mode: $install_mode"
                echo -e "       halting installs at $pkg\n"
                exit 1
                ;;
        esac
    fi
done < <(awk 'NF' $pkg_manifest)

start_installs packages

. $my_dir/tools/make_localinit.sh build
unset new_lmod
