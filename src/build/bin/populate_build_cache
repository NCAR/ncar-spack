#!/bin/bash

function usage {
cat << EOF
Usage: $0 [-j JOBS] [-m MIRROR]

Options
    -j, --jobs          number of concurrent pkgs to cache (default 1)
    -m, --mirror        specify name or path to custom mirror
    -s, --skip-errors   don't halt if one push fails
    -v, --verbose       more information (can be specified multiple times)

EOF
exit
}

if [[ " $@ " == *" -h "* ]] || [[ " $@ " == *" --help "* ]]; then
    usage
fi

# Perform common script setup including environment checks
export my_dir="$( cd "$(dirname "$0")" ; pwd )"
. $my_dir/tools/init.sh

# Set defaults
max_jobs=4

while [[ $# -gt 0 ]]; do
    case $1 in
        -j|--jobs)
            if [[ $1 == *=* ]]; then
                max_jobs=${1#*=}
            else
                max_jobs=$2; shift
            fi
            ;;
        -m|--mirror)
            if [[ $1 == *=* ]]; then
                mirror=${1#*=}
            else
                mirror=$2; shift
            fi
            ;;
        -p|--profile)
            if [[ $1 == *=* ]]; then
                profile=${1#*=}
            else
                profile=$2; shift
            fi
            ;;
        -s|--skip-errors)
            skip_errors=true
            ;;
        -v|--verbose)
            export log_verbosity=$((log_verbosity + 1))
            ;;
        *)
            >&2 echo "Error: unrecognized option $1"
            usage
            exit 1
            ;;
    esac

    shift
done

log_dir=$SPACK_ENV/logs
mkdir -p $log_dir
log_file=$log_dir/cache.$start_time
cache_cmd="spack buildcache push --private"

if [[ $NCAR_SPACK_DEPLOY_TYPE == production ]]; then
    mirror=${mirror:-$NCAR_SPACK_MIRROR_GLOBAL}
else
    mirror=${mirror:-$NCAR_SPACK_MIRROR_LOCAL}
fi

# Job tracking by PIDs
declare -A job_pids

function wait_for_jobs {
    while [[ ${#job_pids[@]} -ge $1 ]]; do
        for jp in ${!job_pids[@]}; do
            if ! kill -0 $jp 2> /dev/null; then
                unset job_pids[$jp]
            fi
        done
    done

    if [[ -f $log_file ]] && [[ $errors_reported != true ]] && grep -q Error $log_file; then
        errors_reported=true
        tsecho "Error: pushed failed! See $log_file for details."

        if [[ ${skip_errors:-false} == false ]]; then
            tsecho "Waiting for jobs to finish"
            wait
            exit 1
        fi
    fi
}

tsecho "Using up to $max_jobs threads to populate cache"
tsecho "Pushing to cache: ${PCOL}${mirror}${DCOL}"

raw_list=$(spack find --format "{prefix} {hash} {name}|{version}|{hash}")
pkg_list=$(awk -v envpath=${SPACK_ENV}/opt '$1~envpath { print $2" "$3 }' <<< "$raw_list")

while [[ ${cache_list+set} != set ]]; do
    case $mirror in
        file://*|/*)
            cache_list="$(ls ${mirror#file://}/*/manifests/spec/*/*.spec.manifest.json 2> /dev/null | sed 's|.*/\(.*\).spec.manifest.json|\1|')"
            ;;
        s3://*)
            cache_list="$(spack python $my_dir/tools/list_cache_s3.py ${mirror#s3://} ${profile:=$NCAR_SPACK_MIRROR_PROFILE})"

            if [[ $? == 1 ]]; then
                tsecho "Error: S3 cache could not be accessed. See above error."
                exit 1
            fi
            ;;
        *)
            read mirror_path profile <<< $(spack python $my_dir/tools/get_mirror_info.py $mirror)

            if [[ -z $mirror_path ]]; then
                tsecho "Error: specified mirror not found in environment"
                exit 1
            else
                mirror=$mirror_path
            fi
            ;;
    esac
done

while read hash triplet; do
    pkg=${triplet//|/-}
    name=${triplet%%|*}

    if [[ $cache_list != *$pkg* ]]; then
        if [[ -f $NCAR_SPACK_ENV_BUILD/.installs ]]; then
            use_cache=$(awk -F: -v spec_hash="$hash" '$2 == spec_hash {print $3}' $NCAR_SPACK_ENV_BUILD/.installs)
        fi

        if [[ $use_cache != no ]]; then
            tsecho "Caching package:  ${GCOL}${pkg}${DCOL}"
            log_cmd "$cache_cmd --only=package $mirror /$hash" >> $log_file
            $cache_cmd --only=package $mirror /$hash &>> $log_file &
            job_pids[$!]=running

            if [[ " ${NCAR_SPACK_LINKED_PACKAGES[@]} " == *" $name "* ]]; then
                unset linked_pkg

                for key in ${!NCAR_SPACK_LINKED_PACKAGES[@]}; do
                    if [[ ${NCAR_SPACK_LINKED_PACKAGES[$key]} == $name ]]; then
                        linked_pkg=$key
                    fi
                done

                tsecho " >> Checking for linked package ${PCOL}${linked_pkg}$DCOL in dependents"
                linked_hash=$(spack dependents -i /$hash | grep " ${linked_pkg}@" | awk '{print $1}')

                if [[ -n $linked_hash ]]; then
                    if ! grep -q "^$linked_hash.* ${linked_pkg}@" <<< "$pkg_list"; then
                        tsecho "Error: Linked package $linked_pkg must be installed before $name can be pushed!"
                        exit 1
                    fi
                else
                    tsecho "Error: Linked package ${NCAR_SPACK_LINKED_PACKAGES[$name]} not found in dependents"
                    exit 1
                fi
            elif [[ " ${!NCAR_SPACK_LINKED_PACKAGES[@]} " == *" $name "* ]]; then
                tsecho " >> Force pushing linked package ${PCOL}${NCAR_SPACK_LINKED_PACKAGES[$name]}$DCOL"
                linked_hash=$(spack find -Ld /$hash | grep " ${NCAR_SPACK_LINKED_PACKAGES[$name]}@" | awk '{print $1}')

                if [[ -n $linked_hash ]]; then
                    log_cmd "$cache_cmd --only=package --force $mirror /$linked_hash" >> $log_file
                    $cache_cmd --only=package --force $mirror /$linked_hash &>> $log_file &
                    job_pids[$!]=running
                else
                    tsecho "Error: Linked package ${NCAR_SPACK_LINKED_PACKAGES[$name]} not found in dependencies"
                    exit 1
                fi
            fi
        fi
    else
        tsecho "Skipping cached package: ${PCOL}${pkg}$DCOL" 1
    fi
    
    wait_for_jobs $max_jobs
done <<< "$pkg_list"

wait_for_jobs 1

update_log_pointers cache
