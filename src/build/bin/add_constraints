#!/bin/bash
#
#   This script is used to add both "externals" - packages found in the current
#   environment that you wish to use - and "requirements/preferences" - settings
#   you wish to impose on packages en masse... typically compiling requirements
#   - to the YAML file.
#
#   Author:         Brian Vanderwende
#   Last Revised:   15:38, 20 Oct 2025
#

function usage {
cat << EOF
Usage: $0 [OPTIONS]

This script can be used to add "constraints" to the build environmment's
spack.yaml. Such constraints include externals, which can be automatically or
manually detected, and requirements to set on packages.

If an external is set to be "fixed", this in turn sets buildable to false and
Spack will be forced to use the external.

Options
    -h, --help              show this help message
    -v, --verbose           provide additional logging messages

EOF
exit
}

if [[ " $@ " == *" -h "* ]] || [[ " $@ " == *" --help "* ]]; then
    usage
fi

# Perform common script setup including environment checks
export my_dir="$( cd "$(dirname "$0")" ; pwd )"
. $my_dir/tools/init.sh

while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            export log_verbosity=$((log_verbosity + 1))
            ;;
    esac

    shift
done

log_dir=$SPACK_ENV/logs
mkdir -p $log_dir
log_file=$log_dir/constraints.$start_time.${SUDO_USER:-$USER}

function manual_require {
    if [[ -z $1 ]]; then
        tsecho "Error: Invalid requirement set ($1); perhaps no core compiler?"
        exit 1
    fi

    mod_list=$(spack python $my_dir/tools/add_requirement.py $1 $2 $3)

    for mod_pkg in $mod_list; do
        tsecho "Set requirement   $GCOL$mod_pkg$DCOL to use $PCOL${1}$DCOL"
    done
}

function manual_external {
    if [[ " $my_meta " == *" fixed "* ]]; then
        spack python $my_dir/tools/add_external.py $pkg_spec fixed $pkg_path || skipped=yes
    else
        spack python $my_dir/tools/add_external.py $pkg_spec buildable $pkg_path || skipped=yes
    fi

    if [[ -z $skipped ]]; then
        tsecho "Adding external   $GCOL$pkg_spec (manual)$DCOL"
        unset skipped
    fi
}

function modify_compilers {
    # Some compilers are provided in a subdirectory of the package root, and thus
    # won't be added if we add the root as an external. We can add these compilers
    # via a second step
    if [[ " $my_meta " == *" compiler "* ]]; then
        for spec in $@; do
            read pkg_name version <<< ${spec/@/ }

            if [[ -f $SPACK_ENV/templates/compilers/modify.${pkg_name}.py ]]; then
                if [[ -n $pkg_path ]]; then
                    root=$pkg_path
                else
                    root=$(spack location -i $spec)
                fi

                tsecho " >> Adding compiler definitions (subdirectory requirement)"
                spack python $SPACK_ENV/templates/compilers/modify.${pkg_name}.py $spec $root
            fi
        done
    fi
}

function process_entry {
    if [[ -z $stored_entry ]]; then
        tsecho "Error: No stored entry to process. Likely indicates a syntax error."
        exit 1
    fi

    tsecho " >> Processing: $stored_entry (type=${BCOL}$my_mode${DCOL})" 1

    case ${my_mode// } in
        externals)
            if [[ " $my_meta " == *" fixed "* ]]; then
                ext_flags=--not-buildable
            else
                ext_flags=
            fi

            if [[ $stored_entry == /* ]]; then
                ext_flags="$ext_flags --path"

                if [[ $stored_entry != *\[*\]* ]]; then
                    tsecho "Error: spec must be delimited in path by [*]"
                    exit 1
                fi

                search_expr=$(sed 's/\[[^]]*\]/\\(\*\\)/g; s/\*/\.\*/g' <<< $stored_entry)
                search_params=$(tr -cd '(' <<< $search_expr | wc -c)
                pkg_paths=$(echo $(tr -d '[]' <<< $stored_entry))

                if [[ -n $pkg_paths ]]; then
                    for pkg_path in $pkg_paths; do
                        if [[ $search_params -eq 1 ]]; then
                            pkg_spec=$(sed "s|$search_expr|\1|; s|/|@|" <<< $pkg_path)
                            pkg_name=${pkg_spec%@*}
                            pkg_version=${pkg_spec#*@}
                        else
                            read pkg_name pkg_version <<< $(sed "s|$search_expr|\1 \2|" <<< $pkg_path)
                            pkg_spec=${pkg_name}@$pkg_version
                        fi

                        if [[ -d $pkg_path ]] && [[ ! -L $pkg_path ]]; then
                            if [[ " $known_externals " != *" ${pkg_path%%/} "* ]]; then
                                if [[ " $my_meta " != *" manual "* ]]; then
                                    auto_result=$(spack external find $ext_flags $pkg_path $pkg_name)
                                else
                                    unset auto_result
                                fi

                                if [[ $auto_result == *spack.yaml* ]]; then
                                    tsecho "Adding external   $GCOL$pkg_spec$DCOL"
                                else
                                    manual_external
                                fi

                                modify_compilers $pkg_spec
                                known_externals="$known_externals ${pkg_path%%/}"
                            fi
                        elif [[ $pkg_path != *sbang ]] && [[ ! -e $pkg_path ]]; then
                            tsecho "Skipping external $BCOL${pkg_spec} (not found!)$DCOL"
                        fi
                    done

                    # Externals should also "use" the core compiler
                    if [[ " $my_meta " != *" floating "* ]]; then
                        manual_require "$core" $pkg_name
                    fi

                    unset pkg_spec pkg_name pkg_version pkg_path
                fi
            else
                auto_result=$(spack external find $ext_flags $stored_entry)

                if [[ $auto_result == *spack.yaml* ]]; then
                    found_list=$(grep "^[^=-]" <<< $auto_result | xargs)
                    tsecho "Adding externals  $GCOL${found_list}$DCOL"
                    modify_compilers $found_list
                fi

                # Externals should also "use" the core compiler unless marked "floating"
                if [[ " $my_meta " != *" floating "* ]]; then
                    manual_require "$core" "$stored_entry"
                fi
            fi
            ;;
        require|prefer)
            my_meta=$(sed "s/core/%$NCAR_SPACK_CORE_GCC/" <<< $my_meta)
            manual_require "$my_meta" "${my_mode// }" "$stored_entry"
            ;;
        *)
            tsecho "Error: Unknown mode $my_mode"
            exit 1
            ;;
    esac

    unset stored_entry
}

# First, let's get the known external prefixes
known_externals=$(spack config get packages | grep prefix: | awk -F: '{print $2}' | sort | uniq | xargs)

# Add package configuration settings
if [[ -f $SPACK_ENV/constraints.cfg ]]; then
    tsecho "Finding specified package configuration in constraints.cfg"

    while read entry; do
        if [[ -z $entry ]]; then
            continue
        fi

        case $entry in
            \#*)
                continue
                ;;
            *=*)
                read var_name var_value <<< ${entry/=/ }
                declare $var_name=$var_value
                ;;
            *'{'*)
                IFS=: read my_mode my_meta <<< ${entry%%\{*}
                my_meta="${my_meta/,/ }"
                ;;
            *'}'*)
                process_entry
                unset my_mode my_meta
                ;;
            *)
                if [[ $entry == /* ]] && [[ -n $stored_entry ]]; then
                    process_entry
                fi

                stored_entry="${stored_entry:+$stored_entry }$entry"
                tsecho "Pending: $stored_entry" 2
                ;;
        esac
    done < $SPACK_ENV/constraints.cfg
fi

if [[ -n $stored_entry ]]; then
    tsecho "Error: Unbounded section detected. Check for completed {} sets."
fi

update_log_pointers constraints
